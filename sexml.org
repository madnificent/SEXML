#+PROPERTY: tangle no
#+PROPERTY: cache no
#+PROPERTY: session yes
#+PROPERTY: results silent
#+PROPERTY: no-expand yes
#+PROPERTY: noweb yes
#+PROPERTY: exports code
#+PROPERTY: padline yes
SEXML

s-expressions for xml is an extensible library which provides a sugar-sweet s-expression syntax for spitting out xml documents.  its initial use is as a converter for a given DTD. it creates a package which exports a function for each ELEMENT (that's an xml tag) in the DTD and translates each of the attributes in the ATTLIST of the ELEMENT into a lispy keyword.  this allows us to use a nice syntax for creating xml documents, based on the DTD to support.  aside from this, the system will become extensible through ContextL.

SEXML currently doesn't aim to use everything we can distil from the DTD, it aims to get just enough information so we can easily generate the XML documents.  there's currently NO checking as to whether or not the generated document will be a valid DTD.  aside from that the library is mainly built in order to support web-standards like html and svg.  if there are any non-XML oddities which should to be supported, they likely aren't supported by default.

* administration
contains all sorts of administrative work.

** asdf system
trivial package for an open source library.  uses cl-ppcre.

#+begin_src lisp :tangle sexml.asd
  (asdf:defsystem :sexml
    :name "S-Expressions for XML generation"
    :author "Aad Versteden <madnificent@gmail.com>"
    :version "0.0.1"
    :maintainer "Aad Versteden <madnificent@gmail.com>"
    :licence "MIT"
    :description "s-expressions for xml is a library which provides a sugar-sweet s-expression syntax for spitting out xml documents based on a DTD"
    :depends-on (cl-ppcre alexandria cxml contextl macroexpand-dammit)
    :serial t
    :components ((:file "packages")
                 (:file "sexml")))
#+end_src

** packages
sexml may generate new packages for the DTD's which it imports, however it will only use a single predefined package.

#+begin_src lisp :tangle packages.lisp
  
  (defpackage :sexml
    (:use :cl-ppcre :alexandria :contextl-common-lisp :macroexpand-dammit)
    (:export :support-dtd :with-compiletime-active-layers :standard-sexml
             :ie-conditionals :xml-doctype))
  
#+end_src

* sexml code structure
sexml provides a simple way to create a new package from a given DTD.  we've split the handling of that function in a few chapters.  it boils down to the following:
- support for creating, populating and exporting symbols in packages
- support for distilling the correct lisp-name from an external name
- support for distilling information from a DTD
- support for customization by virtue of ContextL
- stiching it all together for a final realization

  the following code-snippet describes how everything is in fact connected together.

  #+begin_src lisp :tangle sexml.lisp
    (in-package :sexml)
    
    <<managing-symbols>>
    
    <<lisp-naming>>
    
    <<dtd-information>>
    
    <<hooking-everything-together>>
    
    <<customization-support>>
    
  #+end_src
  
* dtd information
:PROPERTIES:
:noweb-ref: dtd-information
:END:
parsing the dtd isn't particularly complex, but it is the most complex task around.  we don't aim to do anything especially fancy here, we use cl-ppcre to fetch the relevant pieces of information and just distill what's needed.

** structure of a DTD
the DTD contains thtree important informative types of information.
   - ELEMENT :: contains the definition of a tag.  we need to know the name of the tag and whether or not it's empty
   - ATTLIST :: the list of attributes a tag accepts and which values the attributes may have.  we need the list of attributes as strings for the keyword arguments of the function.
   - ENTITY :: a DTD specification may contain C-like macros.  they are literal (though nestable) expansions which can be used roughly anywhere.  they have a name to expand from and a string to expand to.

** approach
the real complexity in the DTD is expanding the entities.  we'll tackle the whole thing as follows:
   - read in the complete DTD and convert it to three lists.  one for the elements one for the attlist and one for the entities.
   - expand all entities internally, which means we'll only need to do one pass over the list of enties.
   - expand the entities in the element and attlist section.
   - parse the string content of element and attlist into objects for reference by the DTD.

** model
the model consists of the following:
   - DTD :: the DTD is given a readable file upon creation which will be parsed at that time.
   - ELEMENT :: an element contains its string name and a list of attribute-objects which the element accepts.
   - ATTRIBUTE :: an attribute consists of a string name.

*** class definition

#+begin_src lisp
  
  (defclass dtd ()
    ((path :initarg :path :reader dtd-path)
     (elements-hash :initform (make-hash-table :test 'equal) :accessor dtd-elements-hash))
    (:documentation "Datastructure which contains all information of a DTD."))
  
  (defclass element ()
    ((name :initarg :name :reader name)
     (attributes :initform nil :accessor attributes)
     (subelements-p :initarg :subelements-p :initform nil :accessor subelements-p)))
  
  (defclass attribute ()
    ((name :initarg :name :reader name))
    (:documentation "represents a possible attribute for an element"))
  
#+end_src

*** correspondence to symbols
elements and attributes have corresponding symbols.  they are accessible respectively through #'function-symbol and #'argument-symbol.  these are implemented here.

#+begin_src lisp
  
  (defgeneric function-symbol (element package)
    (:documentation "returns a symbol for the function of element in package")
    (:method ((element element) package)
      (mk-lisp-symbol (name element) package)))
  
  (defgeneric argument-symbol (attribute package)
    (:documentation "returns a symbol for the argument which can be given to the attribute, imported in package")
    (:method ((attribute attribute) package)
      (mk-lisp-symbol (name attribute) package)))
  
#+end_src

*** altering the dtd
accessor methods for adding and finding elements in the dtd

#+begin_src lisp
  
  (defgeneric dtd-elements (dtd)
    (:documentation "returns the elements of the document")
    (:method (dtd)
      (loop for val being the hash-values of (dtd-elements-hash dtd)
         collect val)))
  
  (defgeneric add-element (dtd element)
    (:documentation "adds <element> to the dtd>")
    (:method ((dtd dtd) (element element))
      (setf (gethash (name element) (dtd-elements-hash dtd))
            element)))
  
  (defgeneric find-element (dtd name-string)
    (:documentation "searches for the element representing <name-string> in the dtd")
    (:method ((dtd dtd) name-string)
      (gethash name-string (dtd-elements-hash dtd))))
  
  (defgeneric add-attribute (element attribute)
    (:documentation "registers the existence of <attribute> for <element>.")
    (:method ((element element) (attribute attribute))
      (push attribute (attributes element))))
  
#+end_src

** parsing the DTD
parsing the DTD is a royal pain in the arse, therefore we bow before the gods that made and maintain CXML.  thanks  Gilbert Baumann and David Lichteblau.  we also kindly accept that it's an LLGPL library as it's just too good for our purpose.

*** hooking it together
all the previous constructions need to be hooked together, so they generate a nice and complete DTD, based on the input file.

#+begin_src lisp
  
  (defun mk-dtd-object (file)
    (make-instance 'dtd :path file))
  
  (defclass dtd-sax-handler (sax:default-handler)
    ((dtd :initarg :dtd :reader dtd))
    (:documentation "sax handler which calls the correct methods on its DTD"))
  
  (defmethod sax:element-declaration ((handler dtd-sax-handler) name model)
    (add-element (dtd handler)
                 (make-instance 'element
                                :name name
                                :subelements-p (not (eq model :empty)))))
  
  (defmethod sax:attribute-declaration ((handler dtd-sax-handler) element-name attribute-name type default)
    (declare (ignore type default))
    (add-attribute (find-element (dtd handler) element-name)
                   (make-instance 'attribute :name attribute-name)))
  
  
  (defmethod initialize-instance :after ((dtd dtd) &key path &allow-other-keys)
    (let ((handler (make-instance 'dtd-sax-handler :dtd dtd)))
      (cxml:parse-dtd-file path handler)))
  
#+end_src
* hooking it all together
:PROPERTIES:
:noweb-ref: hooking-everything-together
:END:
this chapter describes how everything is connected together. leveraging from each of the used libraries.

the first thing the library will do is create an object to manage all of the information in the DTD.  next up is creating a reference to a new package which will store each of the functions.  for each of the elements in the DTD we'll create a new function.  for each of the functions we'll create the argument list.  from the argument list a trivial implementation can be built which should work for most tags.  this is done in the layer specification.  we also introduce a layered function which helps in outputting the arguments which are given to the function.  by default, this provides support for printing lists of arguments as space separated content.

#+begin_src lisp
  (define-layered-function entity-definition-forms (entity package)
    (:documentation "entity-definition-forms is called with an entity and package object (both defined in sexml).  it should return all forms needed to generate the functions.")
    (:method (entity package)
      (declare (ignore entity package))
      nil))
  
  (define-layered-function dtd-support-forms (dtd package)
    (:documentation "returns a list of forms which need to be compiled to support the dtd")
    (:method (dtd package)
      nil))
  
  (define-layered-function entity-printer-forms (entity attr-var body)
    (:documentation "produces the forms which will handle the printing of the tags.  <entity> contains the entity which needs to be printed.  <attr-var> contains a symbol which will contain a plist of attribute-value pairs, the keyword must constist of a string at runtime, the value is not specified.  <body> contains a symbol which will contain a list of content which must be printed within the tag."))
  
  (define-layered-function tag-attribute-content (content)
    (:documentation "prints <content> in a way that it's a valid value for an attribute")
    (:method (content)
      (typecase content
        (string
         (cl-ppcre:regex-replace "\"" content "&quot;"))
        (list
         (tag-attribute-content (format nil "窿" content)))
        (T (tag-attribute-content (format nil "A" content))))))
  
  (defun recursively-flatten (&rest args)
    "recursively flattens a list"
    (loop for arg in args
       append (if (listp arg)
                  (apply #'recursively-flatten arg)
                  (list arg))))
  
  (define-layered-function tag-body-content (content)
    (:documentation "prints <content> in a way appropriate for xml output.  output functions should use this in order to create correct output.")
    (:method (content)
      (format nil "窿蝈沲蝮轹屐骒狒翦泔铘孱舂┅ㄤ彐磲泸篚痧矧舡漪ㄦ殪疳汶徵孱犴濠⑨滗篚痧矧骘翳漪箴邈殒殄轭兼殪寰轭疳汶徵拣徙脶珏钺礤粳翳疳汶徵铄邃瞌屮轶忮骘蝈戾è漪黼漪洵镡赍泗ㄥ鲠骈戾┅疳汶徵黼疳汶徵瀛镡赍泗疳汶徵孱犴濠┅啜痱镧ㄥ鲠飙麒孱ê泔眇殪瀛麸痨弼屐红镝洵麸痨弼屐哄邈豸濠疳汶徵瀛溴沆狎狒轱疳汶徵濠括漪洵篚痧矧舡骘蝽漪疳汶徵濠括祜镳骘屐屙孱轭ㄤ翡屐屙孱趔漪洎泔祆邈啜痱镧括孱糸豉溴骈铋糸镱骘蝽屐屙孱疳汶徵濠┅┅＋孱溥篁沲篝镯辁狒轱篚痧矧盒蚁信以膳雍侯秣邂蝈婧沲篝镯辁狒轱瞽篚痧矧号文轭矧溴麸痱秭殇屮翦铙轱铙犷汨犷珏麸翳忉箦簌篝屙麇躞蔑铘屮籼麇孱徕戾泔铘屮綮狒泔眇殪弭轫瀣箫翳狒翳麽铘邃泔溴骘遽汨镦翦翎珞汜忮珏铄蜥翦洚翳轶屮疳铙轱铙犰祜躞麸痱秭殇犷泔礅轭翳骢钽糸镱犰轸翳躞弪麽铘狒泔眇殪弭轫瀹孱徕扉铉灬弪狒泔眇殪弭轫忮汜躞翳灬弪狎屮疳钿邃狒泔眇殪弭轫瀣麇铄邃麸孱篚蝈蔑铘屮籼栳徙沐篌麸翳屙狒泔眇殪弭轫瀹磲泸镥疳铙轱铙犰麽镢沲轭翳沲蝌孱孱鲩蝻铐孱舢栾麇鲥颥麸孱篚蝈翳狒翳骢钽糸镱麒殂遽汨铄篝邃磲泸锃屮疳铙轱汜祆汜磲脲躞镦翳徙糸鲠翦灬弪麇铄邃麸孱篚蝈翳狒翳孱鲩蝻铐孱栾熹蟋骘翳麒镬糸礤镦翳屮疳铙轱畀泔眇殪狒轱町麇汜骘蜚翳轶怡躞镦弼犰＋忮玳钸篁扉箴ㄤ彐磲泸鏖翳泔眇殪弭轫瀛徙糸鲥灬弪è蝈篝灬弪螬怙澌怙澌戾è灬弪蟓麸徙糸鲠翦祜镳骘灬弪轭灬弪躅戾篌ㄣ镱翦綮红狴弪徙糸鲥灬弪泔祆邈灬弪┅痱镧磲疸狎＇泔铘屮綮哄铙躜瀛徙糸鲥灬弪灬弪蟓麸徙糸鲠翦磲泸镥疳钿溽眄轸啜痱镧棱镤┅磲疸狎＇泔铘屮綮哄铙躜瀛轭徙糸鲥灬弪灬弪蟓麸徙糸鲠翦┅┅＋孱溥篁忉箦箦盱簌篝屙翳忉箦箦盱簌篝屙泸遽翦镱骢钽糸镱骘遽汨镦翳屐屙孱趔轭翳赝秕麴豸脲黠蜾狎躞邃麸篚痧禊翳鲠祯弩镦翳彘狒趄殁豸弩镱沐铒脲鲠祯疳轵轶玳鲥瞵犰雉桢屐屙孱趔狎痱轭翦狍殒翳妁麇蝈轭箝溴翳泔铘孱镦翳翎珞泸遽糸铉骢钽糸镱簌礅镬翳盹篝轫痫螋犷翎箅轶屮痫箝铉翳骢钽糸镱簌礅镬螽翳轶轶滹铄轭翳俭屮盱骢钽糸镱缶灬弪骢钽糸镱轶怩殪麒殂腩秣遽汨镦翳痫篌殁戾狒趄殁豸弩翳骢钽糸镱轶泔眇殪邃轭犷孱鲩蝻铐孱麒殂泔铘衢铙痱镳弪豉扉篝鏖翳狍脲翳脲黠蜾麒殂翳骢钽糸镱栳蟋犷狍鲠祯篝蜷铉蝈痱弩孱糸铉翳狒趄殁豸麒殂箬秕熹忮痱轭翦洚轸镱禊栳犷蝈篝狎珲礤铘狍轸徙沐痿犷翳轭翳狒玳鲥麸轸犷溟筱秭弪麒狒狎脲鲠祯疳轵犷麒狒轶蝈篝轭泔铘孱舢翳蝈篚祠轭骘蝽狎瘐箬邃麸翳扉篝镦礤翳镤铄邃邃麸篚痧矧翳轶屐屙孱舢＋忮玳钸篁扉箴ㄤ彐灬弪箦盱骢钽糸镱īㄤ彐灬弪箦盱盱痱镤蹉弪īㄤ彐躅骘蝽狒翎绛狒趄泔铘孱篝蝈犴狎泔祜铕狒蝈篝镳糸镱螬ㄤ邈灬蝈ㄩ珙矧泔祜铕狒镳糸镱螬ㄦ矧磲篝蝈犴立翎绛狒趄殁豸瀛泔铘孱狎绌┅ㄤ彐躅骘蝽狒翎绛怙澌泔铘孱篝蝈犴狎泔祜铕狒蝈篝镳糸镱螬ㄤ邈灬蝈ㄩ珙矧泔祜铕狒镳糸镱螬ㄦ矧磲篝蝈犴立翎绛怙澌泔铘孱狎绌┅ㄤ彐轭瀛灬弪邃礤翳镤孱糸豉痱轭翦颦骘蝽洪瞽灬弪箦盱盱痱镤蹉弪ㄥ铘轸狒趄鲠怙澌啜骘蝽狒铋ㄣ镱汜翦钺翦篝蜷铉⒓钺礤孱糸豉两堍箦盱汉骘蝽狒翎绛狒趄泔铘孱舣堍" (if (subelements-p entity) ">" "/>") ;; tag
                               (when (subelements-p entity)
                                 "箦盱汉骘蝽狒翎绛怙澌泔铘孱舣") ;; content
                               (when (subelements-p entity)
                                 (concatenate 'string "</" (name entity) ">")))
             ,@(if (null (subelements-p entity))
                   (list attr-var)
                   (list attr-var body))))
  
    
  (define-layered-method entity-definition-forms
    :in-layer sexml-functions
    :around (entity package)
    (let ((sexp-entity (function-symbol entity package))
          (sexp-attributes (mapcar (rcurry #'argument-symbol :keyword)
                                   (attributes entity))))
      `((let* ((key-translations ',(loop for key in sexp-attributes
                                      for expansion in (attributes entity)
                                      append (list key (name expansion)))))
          (defun ,sexp-entity (&rest args)
            (let* ((keys ,(if (null (subelements-p entity))
                              `(loop for (a b) on args by #'cddr
                                  append (list (getf key-translations a) b))
                              `(progn (loop while (keywordp (first args))
                                     append (list (getf key-translations (pop args)) ;; we pop args, so args contains the body in the end
                                                  (pop args)))))))
              ,(entity-printer-forms entity 'keys 'args))))
        ,@(call-next-method))))
  
    
#+end_src

*** exporting function symbols
it is handy if the functions which can be used for creating xml are exported.  this layer handles said exporting.  only the symbol of the function needs to be exported.

#+begin_src lisp
  
  (deflayer export-function-symbol ())
  
  (define-layered-method entity-definition-forms
    :in-layer export-function-symbol
    :around (entity package)
    (let ((symbol (function-symbol entity package)))
      `((export (quote ,symbol) ',(symbol-package symbol))
        ,@(call-next-method))))
  
#+end_src

*** better swank reporting
the function which we currently use only knows the &rest argument.  the spec forces functions which both have an &rest and &key to have an even number of arguments in the &rest argument.  this is not feasible in our solution, as we can supply any number of arguments.  wen swank is loaded, we will still want to get the code-hinting we're used to.  this layer adds code hints, by overriding swank:arglist-dispatch for the functions which we support.

we only load this when swank is loaded.

#+begin_src lisp
  
  ,#+swank
  (deflayer swank-sexml-documented-attributes ())
  
  ,#+swank
  (define-layered-method entity-definition-forms
    :in-layer swank-sexml-documented-attributes
    :around (entity package)
    (let* ((symbol (function-symbol entity package))
           (attribute-symbols (mapcar (rcurry #'argument-symbol (car package))
                                      (attributes entity)))
           (attribute-keywords (mapcar (rcurry #'argument-symbol :keyword)
                                       (attributes entity))))
      `((defmethod swank:arglist-dispatch :around ((symbol (eql ',symbol)) arglist)
          (let ((arglist (call-next-method)))
            (setf (swank::arglist.keyword-args arglist)
                  (loop for attr-sym in '(,@attribute-symbols)
                     for attr-key in '(,@attribute-keywords)
                     collect (swank::make-keyword-arg attr-key attr-sym nil)))
            (setf (swank::arglist.rest arglist)
                  'rest)
            (setf (swank::arglist.key-p arglist) t)
            arglist))
        ,@(call-next-method))))
  
#+end_src

*** xml comments
xml comments reside in a special tag.  we can create a function named #'!-- for this purpose.  this can't be included in the DTD, as xml supports it by default, however other similar formats may want to steal the tag for other purposes.

#+begin_src lisp
  
  (deflayer xml-comments ())
  
  (define-layered-method dtd-support-forms
    :in-layer xml-comments
    :around (dtd package)
    (let ((function-name (mk-lisp-symbol (symbol-name '!--) package)))
      `(,@(call-next-method)
          (defun ,function-name (&rest comments)
            (format nil "<!-- 窿劲蝈沲蝮轹屐骒狒翦泔眄孱趔┅ㄥ痫螋聃雉骢钽糸镱钺礤К簌礅镬疳汶徵骢钽糸镱钺礤┅┅＋孱溥篁轭翦蝾弭屮痨矧弪泔钿轸轱钺祗膳栳镳糸镱犰泔钿轸轱钺篝狒屙孱趔翳轶箬秕熹瞌忮铄邃邃轭盹蝈汜箦蟋怩汜镳糸镱犰禊忮篚痧矧翦怡翳殄泔钿轸轱钺祗灬弪＋忮玳钸篁扉箴ㄤ彐灬弪殄泔钿轸轱钺祗īㄤ彐轭瀛灬弪邃礤翳镤漪洵篚痧矧舡骘蝽洪瞽灬弪殄泔钿轸轱钺祗横蝻躅ㄤ翡疳汶徵濠戾è骢钽糸镱钺礤黼扉箴簌礅镬簌礅镬钺礤А殒疳汶徵濠┅啜括汜祆铄舡礤翳镤ㄤ彐躅骢钽糸镱钺礤ㄣ镱溟糸镱蝈篝狎珞ㄦ矧磲铋⒓…坶凛峻窿肌坼钿殒莪劲泔钿轸轱蝈沲蝮轹屐骒狒翦狎珞┅ㄥ痫螋聃雉骢钽糸镱钺礤К簌礅镬疳汶徵骢钽糸镱钺礤┅┅＋孱溥篁盱滹泗疱滹泗疱箴邈殒麒弪翳漪汜忮骘躅洮翳妁狎祜汜翦狒翳麸镦翳盱滹沲礤铘徭翦翳漪栳忮孱篚痧矧翦洮翳狨珥孱舡鏖翳滹泗疱磲泸锂翳轶磲泸犰祜黧翳躞弪麸箦翳滹泗疱犷镳糸镱犰禊磲脲翳麸痨弼屐翎狨麸磲糸汜祆屙轸翳滹泗疱翳骢祆滹泗疱轶篝矧邃轭滹泗疱翳滹泗疱轸箦戽汜忮屙轸翦怡汜祆轭＇滹泗疱麒殂徙沐痿犷犴秕铘镦骘蝽麸忮蝈钿弪邃徭翦翳屙轸翦滹泗疱＋忮玳钸篁扉箴ㄤ彐灬弪盱滹泗疱īㄤ彐轭瀛灬弪邃礤翳镤漪洵篚痧矧舡骘蝽洪瞽灬弪盱滹泗疱横蝻躅ㄤ翡疳汶徵濠戾è滹泗疱鲠黼扉箴簌礅镬簌礅镬钺礤И滹泗疱疳汶徵濠ㄤ镢豉疱骢钽黼扉箴簌礅镬簌礅镬钺礤т镢豉疱疳汶徵濠ㄤ镢豉疱徜洵漪黼扉箴簌礅镬簌礅镬钺礤п蹒礤铘鏖翳滹泗疱疳汶徵濠ㄤ镢豉疱徜洵骢钽黼扉箴簌礅镬簌礅镬钺礤п蹒礤铘翎绛鏖翳滹泗疱疳汶徵濠┅啜括汜祆铄舡礤翳镤ㄤ彐疳蜥礤翦滹泗疱鲠⒂弭翳轶麸翳滹泗疱骘翳轶盱疳汶徵澧ㄤ彐躅滹泗疱骢钽é蝈篝泔铘孱舂ㄦ矧磲铋窿窿滹泗疱鲠蝈沲蝮轹屐骒狒翦泔铘孱舂┅ㄤ彐磲泸滹泗疱徜洵骢钽ㄦ躅泗轱瞽簌礅镬扉篝箦翩扉篝ф溴骈铋糸镱扉篝я躏翦骢钽糸镱簌礅镬┅扉篝ъ弭扉篝扉篝ф躅泗轱扉篝ф躅泗轱骢钽糸镱簌礅镬┅Ж灬礅溽é蝈篝狎珞ㄣ镱汜翦钺翦篝蜷铉ㄦ躅汜祆К滹泗疱骢钽ㄡ痧禊骢钽糸镱狎珞┅┅┅ㄤ彐磲泸滹泗疱徜洵漪翎漪脲狨麸屙轸皓扉篝ю蝻珙扉篝箦翩К滹泗疱鲠扉篝ф矧磲ь殪⒓∧厦再信辆翎漪洎麒孱狨麸屙轸扉篝К滹泗疱徜洵骢钽黼扉箴簌礅镬翎К簌礅镬疳汶徵滹泗疱徜洵漪洎┅┅ㄥ痫螋聃雉滹泗疱鲠颟К簌礅镬疳汶徵滹泗疱鲠颟ㄥ痫螋聃雉滹泗疱骢钽К簌礅镬疳汶徵滹泗疱骢钽┅ㄥ痫螋聃雉滹泗疱徜洵骢钽К簌礅镬疳汶徵滹泗疱徜洵骢钽┅ㄥ痫螋聃雉滹泗疱徜洵漪洎К簌礅镬疳汶徵滹泗疱徜洵漪洎┅┅＋孱溥篁箝眇戾躞麇箝眇扉纟翳躞镦箦盱篝犷溽蜾盱铒翎糸镱怡篚痧禊轭灬弪麒殂屮翦钿泔铘衢铙翳翳蝈痱弼轱躞灬弪螽翳轶磲脲轸遽箝弪麸瘐忪轶篚痧矧骘脑漠＋忮玳钸篁扉箴ㄤ彐灬弪篝犷溽蜾箦盱ㄥ痫螋骢钽糸镱簌礅镬＋篦犷篦犷氕箦盱滹沲礤铘邃狒趄殁豸弩箦盱骢钽糸镱箦盱盱痱镤蹉弪盱泔眄孱趔┅＋孱溥篁磲钺玳铉簌礅镬盒蚁信以膳雍侯秣邂蝈婧磲钺玳铉簌礅镬号文簌礅镬磲钺珏礤铘怙殪滹黝麸泸遽糸铉疳汶徵麒孱蝈聃弩翦犷痱秭殇轭麽麸泸遽翦疳汶徵溴骈铋糸镱箫翳疳汶徵轶溴骈铄轭麽遽箝弪镱翳妁弩麇汜蝈痱弩孱疳汶徵怡翳疳汶徵轸箦戽狍骈蝮狎珲礤铘犷翳扉篝镦簌礅镬麒殂鏖祆铄邃麸忮屮痫螋邃灬翦虍鏖翳翳狒轭黹钿麇轫痨屙孱翳赭骢钽糸镱麒殂狎躞邃轭翳磲轭忪镢氘＋忮玳钸篁扉箴ㄤ彐躅黼疳汶徵瀛镡赍泗钺礤泸遽翦铄疳汶徵镡赍泗扉篝矧ㄦ轭洵疳汶徵钺礤磲脲疳汶徵钺礤┅┅ㄤ彐躅疳汶徵瀛屮痫螋蟓簌礅镬疳汶徵簌礅镬㈨犭弩篚蝈疳汶徵腩秣轸铄邃麸屮痫螋簌礅镬犷屮痫螋轸ㄥ痫螋簌礅镬ㄦ轵篝疳汶徵濠箦翩ㄣ潋灬篝疳汶徵濠ㄣ镱簌礅镬铋飑簌礅镬ㄤ彐躅疳汶徵瀛溴沆狎狒轱疳汶徵濠泸遽翦溴骈铋糸镱骘翳疳汶徵澧戾è疳汶徵ㄦ轵篝疳汶徵濠ㄥ痫螋蝈篝疳汶徵濠┅啜溴骛徙脶珏疳汶徵瀛钺礤疳汶徵濠ê屮痫螋厘痫螋螬┅＋孱溥篁扉箴钺黹铉盒蚁信以膳雍侯秣邂蝈婧扉箴钺黹铉号文趄犷箪狒弩篝蜷铉镦屮翦蝾犰溴骈铋糸镱轭麸扉箴篝蜷铉螽鲥蝙扉趑戾轶腩秣徕秕翳屮翦蝾犰骘蝽狒怡溴驷蹯衄轸汜忮蝻蹒桁犷翳轭绠忮篝彐骘螋篝踱栳忮孱轫痨屙孱翦麒殂趄犷箪狒弩屮翦蝾犰篝蹑麸箫礤翳轭翳狒箬秕熹祜镫盹蝈矧戾篌扉脲扉箴泔溴＋忮玳钸篁扉箴ㄤ彐躅黼扉箴簌礅镬ㄥ铘轸疳汶徵濠麒孱扉篝疳汶徵濠箦翩疳汶徵ㄦ轵篝疳汶徵濠┅麒孱疳汶徵屦疳汶徵濠箦翩疳汶徵疳汶徵瀛钺礤疳汶徵濠┅箦翩孱糸豉ㄣ飙痧泸搴蝈珏蝈痨徙瀛犰④塄孱糸豉⒓┅箦翩孱糸豉ㄣ飙痧泸搴蝈珏蝈痨徙瀛犰④堠孱糸豉⒕┅箦翩孱糸豉ㄣ飙痧泸搴蝈珏蝈痨徙瀛犰孱糸豉┅箦翩孱糸豉ㄣ飙痧泸搴蝈珏蝈痨徙瀛犰⑦孱糸豉┅箦翩孱糸豉ㄣ飙痧泸搴蝈珏蝈痨徙瀛犰⒑孱糸豉┅箦翩孱糸豉ㄣ飙痧泸搴蝈珏蝈痨徙瀛犰ㄛ岘荸ㄛ镰谳孱糸豉④鼙苘并┅箦翩孱糸豉篝蜷铉躔汜箦孱糸豉┅换翳轶轶痫螋徕戾怩滹弩瞌黠螂铋沐镱盹溴蝾盹溴狍篚礤ㄩ铘弪孱糸豉ㄦ轭洵疳汶徵疳汶徵濠┅＋孱溥篁